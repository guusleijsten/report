

%This thesis describes   exploit explicit datapaths in an LLVM-based compiler for an ultra-wide SIMD architecture.

%TODO: rewrite this in my own words
%This thesis describes the development of an LLVM-based compiler for a wide SIMD architecture. In this chapter, the motivation of this thesis is described, together with the generic features of a wide SIMD architecture. Then, the problems of the existing compiler, and the final goal are introduced in the problem statement. The thesis overview shows the structure and basic information of each chapter in this report.

Embedded systems are everywhere, over ninety percent of all microprocessors are manufactured as components of embedded systems.
Never have we had such growth in the use of such embedded devices. Nowadays, most people carry a mobile phone that is more powerful than the computer I played my first game on in `92. As embedded applications are adopting more sophisticated algorithms, a wide consensus on performance and power efficiency arises. %This embedded streaming processor consumes tens of pJ per operation (pJ/op) and the battery capacity is only sufficient for playing video applications for a few hours \cite{simd}.

There are dedicated processors for all kinds of embedded applications like video/image processing, deep learning, and other advanced algorithms.
Embedded systems like mobile phones have to run high-performance applications like wireless signal processing and 3D processing \cite{dongrio1} which is made possible by powerful processors (ARM64 / AArch64) that run at high clock speeds. However, these kinds of devices often have a limited energy source and because it is a handheld device, heat produced by power dissipation is also of concern.

%brugzin Luc
The advantage of an ultra-wide \emph{Single Instruction Multiple Data} (SIMD) architecture is its wide vector operations that run in parallel with a control processor. For certain kernels, we can exploit parallelism by processing multiple operations in parallel instead of processing them sequentially. Therefore, we can meet the same performance at a low clock frequency and thus low voltage, thereby greatly reducing energy consumption \cite{dongrio2} and power dissipation.% (power is proportional to the clock frequency). 
%een techniek om energie nog verder te optimaliseren, door bypassen van je rf, en dat kan automatisch en explicit, en in dit geval kijken we naar expliciet.

%to program these kind of architectures / bruggetje
Compilers have a significant role in the design of computer architectures. During the design phase of an architecture, one may want to see how efficient such design is or what impact certain design decisions have. To analyze how efficient applications can execute on a design, we need a compiler to translate an application to machine code, which is then used to simulate the execution of such architecture. Therefore, architecture design and compiler development go hand in hand.  

The \emph{Electronic Systems} (ES) group at the \emph{Eindhoven University of Technology} (TU/e) is doing research in a wide SIMD with low energy features in order to achieve a programmable platform with a high energy efficiency \cite{dongrio1}. The current compiler is developed completely in the LLVM framework but does not generate code for explicit datapaths. However, there is an older version of the compiler, which we refer to as the legacy compiler that does generate code with explicit datapaths. It uses LLVM's front-end with a custom back-end that inhibits maintainability and does not benefit from developments in the field of compilers.

\newpage \section{Motivation}
%avoid mentioning the compiler course, just mention that compilers are 'vet handig'.
This master thesis aims at completing the transition to LLVM such that all design options, including explicit datapaths, are supported. We would highly benefit from having a fully functional compiler that is implemented in LLVM. There are compiler developers working around the clock on many different architectures, e.g. xCORE (multicore microcontrollers), AArch64 (mobile phones), and x86 (modern computers)\footnote{www.xmos.com/products/silicon}. With an LLVM-based compiler, we may benefit from improvements that these compiler developers make and greatly improve maintainability of the compiler.

We measure the efficiency of the generated code for a very low energy ultra wide SIMD architecture in terms of code quality and energy efficiency. We do this by comparing a practical LLVM-based compiler to a legacy custom build compiler and assess efficiency using handwritten references. We want to know how low power this architecture truly is and see if we can make a successful transition to LLVM. Many companies have standardized to LLVM already, and it is very attractive for academic use. %TODO: rewrite this paragraph

We focus on improving energy efficiency by implementing an optimization technique to reduces communication with the \emph{register file} (RF). The RF is one of the most power-hungry, and often used components in a processor. 

We analyze the gain in energy efficiency by exploiting explicit datapaths. The SIMD architecture has busses that contain time-dependent values. Accessing one of these busses is cheaper than accessing a register file in terms of energy. Therefore, we use these buses to decrease traffic with the register file. Thereby, improving energy efficiency. 

% Research to energy efficient other approaches Shafflic and emb. sys. abstract barry.

\section{Problem Statement}
For the architecture at hand, several features were chosen. Each combination results in a different hardware configuration:
\begin{itemize}
\item We use pipelining (where each stage takes one clock cycle). We can choose a four-stage or a five-stage pipeline design.
\item	We can configure the bit-width of the data that it operates on to 32 or 16 bits. With smaller 16-bit you may further improve energy efficiency, but requires knowledge of the programmer and consideration during application development. The 32-bit data width may be sufficient for embedded applications but is still smaller than 64-bit architectures.
\item	We have also considered extending the \emph{Instruction Set Architecture} (ISA). For example, it may be beneficial to have a  \emph{Functional Unit} (FU) that can do multiply-accumulate instructions for, e.g. signal processing filters, like \emph{Finite Impulse Response} (FIR) filters, linear algebra, like matrix multiplication, and \emph{Convolutional Neural Networks} (CNN). %TODO: find and fix comma misuse within clauses
\item 

%Operand bypassing exploits busses of a bypass network to pass values between software pipeline stages. This feature reduces accesses to register files by bypassing the value rather than putting it in a register. There are two version of bypassing for this SIMD i.e. implicit bypassing and explicit bypassing. With implicit, also called automatic bypassing, dedicate hardware detects and exploits these bypasses. With explicit bypassing, it is the compilers responsibility to exploit them.
\end{itemize}

In general, it is desired to have a compiler that conforms to some basic characteristics, (i) it should be easy to maintain, (ii) it should be easy to add other features and (iii) it should produce high-quality code. Moreover, it should always generate correct code.

The legacy compiler has input language limitations, maintenance problems and 
does not always generate correct code.
\begin{itemize}
\item \textbf{Input Language Limitations:} One needs to implement an application in OpenCL to get vectorized code. Moreover, it only supports a subset of the OpenCL language. Altogether, this puts the responsibility on the programmer which is something that we want to avoid. Furthermore, the generated code is not vectorized when we use C code as input language. 
\item \textbf{Maintenance:} The back-end of the legacy compiler is too custom and, maintainability would benefit from standardization. Namely, because it is difficult to implement new features and not all considered features have been developed.   
\end{itemize}

The new compiler has drastically improved maintainability and uses LLVM?s auto-vectorizer to generate vector instructions. Compared with the old compiler LLVM-based compilers are more flexible and supports a large number of input languages. The optimization passes supplied by LLVM also improve the quality of the generated code. Furthermore, the development in LLVM makes it easy to update the compiler and can, therefore, benefit from developments in compiler technologies. However, the new compiler does not support all features. Namely, it can only generate code for a target machine with four pipeline stages, implicit datapaths, and a bit-width of 32 bits. We will maintain and add features to the new compiler with a focus on the exploration of explicit datapaths.

%TODO: vraag : een hoop werk om een zin te zeggen haha moet hier nog iets volgen? moet hier nog iets na komen
The main problem is ``How to generate efficient code for SIMD that exploits explicit datapaths?". 

%is no support for a five stage pipeline configuration and only implicit datapaths have been considered.  
%TODO: ask : completely avoid hardware generation? or mention? that current implementation does allow many of these features and configurabilities, but consists of multiple implementations and has too much code duplication.

% So for that reason we have maintained the compiler additional to developing the compiler requirements of this thesis.
%\section{Contributions}
%This thesis onderzoek gedaan naar een compiler voor llvm voor een architectuur dat is designed by the TU/e. We aim to having a fully functional compiler that is implemented in LLVM. The compiler course is a course where students are introduced in compiler technologies and this relatively easy to understand architecture can help student to get introduced in LLVM. There are developers working around the clock on other architectures, e.g. xCORE (multicore microcontrollers), x86 (nowadays computers) (link to www.xmos.com/products/silicon) and AArch64 (mobile phones). Having knowledge on LLVM may help these students to improve their knowledge on such computer architectures.  

%I aim to provide research in efficiency of explicit datapaths for our ultra low power SIMD architecture. In general, I will consider different approaches to exploit them within LLVM and add this functionality to the compiler. For practical use, this architecture could be used as accelerator or off-the-shelf module or even embedded processor for certain applications. extension, 

\section{Thesis Overview}


In the next chapter, we describe the background information that will provide key information to this thesis, including a basic introduction to LLVM, an overview of the SIMD architecture and related work. Chapter \ref{chapter:compiler} discusses LLVM-based code generation for our target architecture with a focus on explicit datapaths, followed by an evaluation in Chapter \ref{chapter:evaluation}. We will show future work %in Chapter \ref{sec:future_work} 
before concluding in Chapter \ref{chapter:conclusion}.

%This thesis is organized as follows.  Chapter \ref{chapter:compiler} is devoted to LLVM-based code generation for SIMD with focus on explicit datapaths. Chapter \ref{chapter:evaluation} gives evaluations and preliminary conclusions. Chapter \ref{chapter:conclusion} concludes and gives any future work. 