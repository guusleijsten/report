We have chosen which benchmarks will be used to evaluate each of the proposed solutions and given them in Table \ref{table:benchmarks}. These benchmarks will be developed and compiled, which will then be compared to a handwritten assembly version and to compiled code that would have been produced by the legacy compiler. 

\begin{table}[h]
\caption{Table with benchmark kernels that we have chosen to evaluate each of the proposed solutions.}
\begin{center}
\begin{tabular}{@{}p{0.3\textwidth-2\tabcolsep}p{0.7\textwidth-2\tabcolsep}@{}}
\toprule
\textbf{Category:} & \textbf{Kernel:} \\ \hline
{Signal Processing} & Fast Fourier Transformation (FFT) \\
								& Finite Impulse Response (FIR) filter \\
{Linear Algebra Kernels} 	& Vector addition \\
            					& Vector dot product \\
            					& Matrix transpose \\
            					& Matrix multiplication \\
{Image Processing} 	& Blurring filter: \\
					& - Gaussian blur \\
					& - Median blur \\
					& Fast Focus On Structures (FFOS) on Organic Light Emitting Diode (OLED), which consists of the following kernels \cite{ffos}: \\
					& - Otsu's method \\
					& - Binarization \\
					& - Erosion \\
					& - Projection \\
%	& Vector addition		& Gaussian blur\\
%	& Vector dot product		& Median blur \\
%							& Matrix transpose		& FFOS \\
%							& 					& - Otsu's method \\
%							& 					& - Binarization \\
%							& 					& - Erosion \\
%							& 					& - Projection \\
\bottomrule
\end{tabular}
\end{center}
\label{table:benchmarks}
\end{table}%


%\section{Benchmarks}\label{sec:benchmarks}
%\begin{itemize}
%    \item Signal processing kernels:
%        \begin{itemize}
%            \item Fast Fourier Transformation (FFT) algorithm:
%            \item Finite Impulse Response (FIR) filter:
%        \end{itemize}
%    \item Linear algebra kernels:
%        \begin{itemize}
%            \item Vector addition,
%            \item Vector dot product,
%            \item Matrix transpose,
%            \item Matrix multiplication.
%        \end{itemize}
%        \item Image processing kernels:
%    \begin{itemize}
%        \item Blurring algorithm:
%        \begin{itemize}
%            \item Gaussian blur,
%            \item Median blur.
%        \end{itemize}
%        \item Histogram
%        \item Fast Focus On Structures (FFOS) on  Organic Light Emitting Diode (OLED), which consists of the following kernels \cite{ffos}:
%        \begin{itemize}
%            \item Otsu's method,
%            \item Binarization,
%            \item Erosion,
%            \item Projection. 
%        \end{itemize}
%    \end{itemize}
%\end{itemize}

What metric would be suitable to evaluate the different approaches with each other and with the legacy compiler?

First of all, we could compare the number of cycles of the compiled code to that of the handwritten assembly and to resulting code of the legacy compiler, to assess efficiency in terms of execution speed. Furthermore, the ratio of bypass register accesses and normal register accesses may be used to determine efficiency of our bypass allocation approaches. Again, this ratio can be compared to that of the legacy compiler and handwritten versions.

We have yet to implement the benchmarks, and access efficiency of our approaches on these benchmarks. From that will follow how much accesses to the RF can be avoided. We will simulate the processor at HDL level to assess energy consumption and simulate execution of the assembly, resulting from compiling our benchmarks with implicit and with explicit bypassing. Then we can determine how much energy each of the kernels requires, and therefore determine how much energy we can save by adding explicit bypassing on top of the compiler targeting an SIMD architecture. 